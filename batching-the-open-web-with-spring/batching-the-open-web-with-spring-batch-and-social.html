<html xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head><title>The Title</title>
    <link rel='stylesheet' href='default.css' type='text/css' media='all'/>
    <script src="jquery-1.8.3.min.js"></script>
    <script src="github-files.js"></script>
    <style type="text/css"> .sidebar h1 {
        font-size: smaller;
        color: green;
        display: run-in;
        text-transform: uppercase;
        margin-right: 30px;
    }

    .sidebar {
        background-color: yellow;
        padding: 10px;
    }

    .source {
        font-family: monospace
    } </style>
    <script> function code(file, div, lineStart) {
        var angleBrackets = function (i) {
            while (i.match('<') != null) i = i.replace('<', '&lt;');
            while (i.match('>') != null) i = i.replace('>', '&gt;');
            return i;
        };
        $.getGithubFileByFilePath('joshlong', 'spring-social-flickr', file, function (contents) {
            var html = angleBrackets(contents + '');
            $(div).html('<pre><code>' + html + '</code></pre>');
        }, lineStart ? lineStart : 16);
    }
    $(function () {
        $(".source").each(function (indx) {
            var ceNode = $(this);
            var fn = ceNode.html().trim();
            console.log(fn);
            var start = ceNode.attr('start');
            if (start || typeof start != 'undefined') {
                start = parseInt(start + '');
                code(fn, ceNode, start);
            } else {
                code(fn, ceNode);
            }
        })
    }) </script>
</head>
<body><h1> Batching the Open Web with Spring Social and Spring Batch </h1>

<p> It's the new year and with it come new years resolutions. This year, I got a quick start on one of them: I wanted to
    download my photos from <A href="http://flickr.com">Flickr</a>. I like Flickr, but it's just not as integrated into
    my tools and life as I'd like it to be, so I wanted to migrate my photos to another service that was both free and
    more integrated. I needed a way to get my photos off of Flickr. There are many tools out there for doing this, but
    the tools that are out there seem to die before the job of downloading my tens of thousands of photos is done (yes,
    I have a professional Flickr account!) or they're outdated and don't run because they use an older API or they use
    some sort of delicate hack. So, I decided I'd solve the problem myself, and solve it I did! </p>

<h2> Making the Connection with Spring Social Flickr</h2>

<P> The first step in getting my photos off of Flickr is to connect to Flickr. As many of you will know, <a
        href="http://springsource.org/spring-social">Spring Social</a> makes it very easy to build applications that
    connect to web service provider APIs like <a
            href="http://github.com/SpringSource/spring-social-facebook">Facebook</a>, <a
            href="http://github.com/SpringSource/spring-social-twitter">Twitter</a>, and <a
            href="http://github.com/SpringSource/spring-social-linkedin">LinkedIn</a>. Spring Social enables this by
    providing a core authentication and authorization hook that in turn provides a generic framework for connecting and
    working with OAuth 1.0, 1.0.a, and OAuth 2.0-based APIs. This is often the most tedious part of connecting to an
    API, after all, so it's nice to have this chunk removed. This, coupled with Spring's already very robust REST
    support in the form of its <CODE>RestTemplate</CODE>, makes it very simple to provide bindings for <EM>any</EM>
    service provider! Many, many people have. For a more complete - though by no means exhaustive - list, check out <a
            href="https://github.com/SpringSource/spring-social/wiki/Api-Providers">the Spring Social Wiki page for a
        list of the other bindings that have, if you'll pardon the expression, <EM>sprung</em> up</a>. </p>

<P> The Flickr binding is of interest to me in solving this problem. The original <a
        href="https://github.com/ranjan-rk/spring-social-flickr">Flickr binding</a>, it would be fair to say, looks very
    promising indeed, but is a <EM>little</EM> unfinished. <a href="http://github.com/joshlong/spring-social-flickr">I've
        had to make some small tweaks</a>. The thrust of the additions are some small changes to the binding itself, as
    well as the addition of <a href="http://springsource.org/spring-batch">a Spring Batch-based downloader</a>. </P>
<img width="200" src="oauth_logo.png" style="float : left; margin-right : 20px; "/>

<P><A href="http://en.wikipedia.org/wiki/OAuth">OAuth</a> is a complicated, multi-step dance. Basically, it's a secured
    conversation. </p>
<OL>
    <LI> The consumer of a service starts a conversation with a service provider and asks the service provider to let
        the client work with the service provider's data (typically on behalf of a flesh-and-blood human being whose
        data will be manipulated).
    </lI>
    <LI> The service provider authenticates the user (this is what happens when, for example, you're so often redirected
        to Facebook.com to login to forms on various web pages).
    </lI>
    <LI> Once authenticated, the service provider redirects back to the client application with a token in the
        response.
    </lI>
    <LI> The client must provide this token on all requests to the service provider</lI>
</ol>
<p> To complicate matters worse, this process looks slightly different depending on which version of the specification
    you're referring to, 1.0, 1.0a, and 2.0. If this sounds like a lot of work, that's because <em>it is!</em>. But, you
    need not meet the burden alone. Spring Social's got you covered. </P>

<P> Setting up Spring Social is easy in a web application. You can work with Spring Social's API bindings outside of a
    web environment, but you're going to need certain values to interact with the web services. Usually, you'll need at
    least a <em>client ID</EM> (called a <EM>key</EM> in Flickr parlance) and a <EM>client secret</EM> (called a <EM>secret</EM>
    in Flickr parlance), which you can get from the service's developer portal. The <A
            href="http://www.flickr.com/services/developer/api/">Flickr developer portal</A> makes obtaining these
    values straight forward. Once <A href="http://www.flickr.com/services/apps/create/apply/">you've applied for a
        key</a>, simply note the client ID and the client secret. If you've already created an application, then you can
    see your API keys and secrets at <CODE>http://www.flickr.com/services/apps/by/<b>YOUR_USERNAME</b></code>, where
    <code>YOUR_USERNAME</code> is to be replaced with your Flickr account name. </p>

<P> The next thing you'll need are an access token and an access token secret. These values are created dynamically for
    each authenticated user. So that we're clear, the <em>client ID</em> and <em>client secret </EM> identify the <EM>application</EM>
    that's connecting to Flickr. They do not identify the <EM>user</EM> on whose behalf this application is connecting.
    To obtain those values, the user needs to satisfy the sign in flow described above, in a web application that Flickr
    can redirect back to. You'll need to tell Flickr which URL it should redirect back to, with the requested access
    token, when you configure your application. </p>

<h3>Setting Up Spring MVC </h3>

<P> To demonstrate what this all means in practice, let's first look at the anatomy of a typical Spring Social web
    application, the <CODE>web</code> module in my Spring Social Flickr fork. The first thing to look at any in web
    application is the <code>web.xml</code> file and associated configuration. In our application, it looks like this:
</p>

<div class="source" start="1">web/src/main/webapp/WEB-INF/web.xml</div>
<p> We have setup several Servlet <CODE>Filter</CODE>s that make dealing with web requests easier. Here's a look at some
    of them: </p>
<OL>
    <LI><B>org.springframework.web.filter.CharacterEncodingFilter</b> - forces requests into and out of the application
        into a certain encoding, in this case, UTF 8
    </LI>
    <LI><B>org.springframework.web.filter.HiddenHttpMethodFilter</b> - browsers can only send HTTP <CODE>POST</code> and
        <CODE>GET</CODE> requests, which makes them blind to other commonly used HTTP requests, including HTTP requests
        of type <CODE>PUT</CODE> and <CODE>DELETE</CODE>, both commonly used in building RESTful applications. This
        filter circumvents that limitation by <EM>routing</EM> incoming HTTP requests of type <CODE>POST</CODE> or
        <CODE>GET</CODE> to the appropriate Spring MVC controller, including those only exposed via <CODE>DELETE</CODE>
        and <CODE>PUT</CODE>, based on the presence of a <CODE>_method</code> header in the request.
    </LI>
</oL>
<p> The rest of the configuration is pretty typical: we configure the <CODE>DispatcherServlet</code>, which in turn
    bootstraps the Spring <CODE>ApplicationContext</code>. The <CODE>DispatcherServlet</code> needs to know what type of
    application context to use, so we have several <CODE>&lt;context-param&gt;</code> elements that tailor the behavior
    of the <Code>DispatcherServlet</code>. The <code>contextInitializerClasses</code> <code>context-param</code>
    specifies a class that Spring will call right before it begins constructing the <CODE>ApplicationContext</CODE>. It
    is here that we specify the <CODE>org.springframework.social.flickr.config.AnnotationConfigWebApplicationContextInitializer</CODE>,
    a class that we provide to configure our web application. Here's the code:</p>

<div class="source">
    web/src/main/java/org/springframework/social/flickr/config/AnnotationConfigWebApplicationContextInitializer.java
</div>
<p> This class is called right before the <CODE>ApplicationContext</CODE> instance is configured and run by Spring,
    giving us a chance to tell it things about the application. In our case, most of the work is simply in registering
    which packages Spring should automatically scan to auto-register components. We tell it to read all the components
    in, or below, the package that the class <code>org.springframework.social.flickr.HomeController</code> lives in.
    This includes all classes annotated with <CODE>@Component</CODE>, <CODE>@Controller</CODE> and
    <CODE>@Configuration</CODE>. Then, to support reading required properties from a file located outside of the web
    application (in this case <CODE>~/flickr.properties</CODE> - we build up and contribute a
    <CODE>PropertySource</CODE> to the <CODE>ApplicationContext</CODE> inside the <CODE>registerPropertiesForFlickrConnection</CODE>
    method. </p>

<p> There are two classes in <code>org.springframework.social.flickr.config</code> that are Java application
    configuration and are processed when the application starts up because they have <CODE>@Configuration</CODE> on
    them. The first is the basic Spring MVC configuration, shown below. </p>

<div class="source">web/src/main/java/org/springframework/social/flickr/config/WebMvcConfig.java</div>
<p> Spring will see that this class contains <CODE>@EnableWebMvc</CODE> and it will bootstrap Spring MVC, providing
    useful defaults for lots of things based on whether the correct dependencies are on the classpath, including RESTful
    responses through XML- and JSON-to-object marshalling (you need a JAXB implementation or Jackson), JSR 303-based
    bean validation (you need Hibernate validator), file uploads ( <CODE>commons-fileupload</code>, or Servlet 3
    support), and more. So, we don't need to do a lot to get the basic machinery working. All we're doing here is
    instructing Spring MVC to do a few things specific to our application: </p>
<OL>
    <LI><b>addViewControllers(ViewControllerRegistry registry) </b> tells Spring MVC to forward requests for the
        registered paths (for example, <CODE>/signin</CODE>) directly to the appropriate view (<CODE>/WEB-INF/jsp/signin.jsp</code>),
        and don't bother trying to invoke a Spring MVC controller before hand.
    </LI>
    <LI><b> addResourceHandlers(ResourceHandlerRegistry registry) </b> tells Spring MVC to forward requests for a given
        path or directory directly to the resources on a file system, and don't bother trying to resolve these paths
        through the normal controller resolution process.
    </LI>
    <LI><b>configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)</b> is very useful if you want
        your Spring application to sit at the root of servlet context (e.g., "/") and handle all requests. If you
        configure a servlet this way, than that servlet becomes responsible for all requests into the container, even
        those the servlet that's so configured is not prepared to handle, like <code>.jpg</code> images or
        <code>.js</code> files and other static resources. To get around this, Spring MVC can delegate to the <EM>default
            servlet</EM> on many different web containers, letting it handle those requests. Because the location of the
        <EM>default servlet</EM> is non-standard, you have to ask Spring MVC to do this for you. It works for a variety
        of containers, but it may not always work.
    </LI>
    <LI><B>@Bean public ViewResolver viewResolver()</B> finally, we contribute using regular Java configuration style a
        bean of type <CoDE>ViewResolver</CoDE>, which is a Spring MVC SPI class that resolves views given a generic
        String. So, given the String <EM>"signin"</EM>, it might resolve it to a <A href="">Thymeleaf</a> template, or a
        <code>.jsp</code> page, or an Apache Tiles view, or any of numerous other types of <CODE>View</CODE> types, all
        based on the heuristics unique to each <CODE>ViewResolver</CODE> implementation. In our application, we want
        <code>/signin</code> to resolve to the <code>.jsp</code> page <code>/WEB-INF/jsp/signin.jsp</code>, so we
        specify a <CODE>ViewResolver</CODE> of type <CODE>InternalResourceViewResolver</CODE> and specify the
        <em>prefix</em> and <em>suffix</em> properties that when taken together along with the view string, describe a
        fully qualified <code>.jsp</code> page's path.
    </LI>
    <LI><b>@Bean public CommonsMultipartResolver multipartResolver()</b> contributes an implementation of <CODE>CommonsMultipartResolver</CODE>
        under the well-known name <CODE>multipartResolver</CODE>. Spring will delegate to this when handling file
        uploads.
    </LI>
</OL>
<h3>Setting up Spring Social </h3>

<P> Next, let's look at how to introduce Spring Social. This happens in another class annotated with <CODE>@Configuration</CODE>
    in the same package as <CODE>WebMvcConfig</CODE>, called <CODE>SocialConfig</CODE>. </p>

<P> Spring Social has a lot of duties. It has to handle connecting to service providers on behalf of users with OAuth,
    but in order to do that, it must keep some state. After all, it has to transmit the access token and access token
    secret that it acquired on all subsequent requests, which means it needs to <em>remember</EM> those values. </P>

<P> Additionally, it needs to be easily integrated with your application's notion of a <EM>user</EM>. Even if you do let
    users log in via Facebook or Twitter, your still has its own per-user state to be managed. Perhaps your application
    handles authentication via Spring Security which in turn talks to LDAP or Active Directory. Perhaps you have a
    lightweight <CODE>users</CODE> table. Whatever the case, Spring Social tries to make it straight forward to link
    service provider identities with your application's notion of an identity. </P>

<P> Finally, Spring Social bindings provide a type-safe Java API that maps to the domain model and API calls of the
    target webservice. This API binding is of course specific to each web service. A Twitter binding has the notion of
    <EM>tweets</EM> and <em>timelines</em>. The Facebook binding has the notion of <EM>friends</EM> and <EM>status</EM>.
    And, of course, the Flickr binding has the notion of <EM>photos</EM> and <em>photo sets</EM>. This type safe binding
    must also be configured. With those stated responsibilities in mind, let's dissect the <CODE>SocialConfig</CODE>
    class. </p>

<div class="source">web/src/main/java/org/springframework/social/flickr/config/SocialConfig.java</div>
<DIV class="sidebar"><h1> A Quick Refresher on Java configuration </h1>

    <P> For those that haven't used the Java configuration style, a quick refresher: Spring will load this class when it
        starts up the <CODE>ApplicationContext</CODE>, and it'll run through all the methods annotated with
        <CODE>@Bean</CODE>, analyzing the arguments each declares (which it tries to satisfy as dependencies), and, once
        it has provided a valid reference to the dependency, it invokes the method. It takes - by default - the method
        name is a bean's <CODE>id</code>, and it takes the return value's class as the <code>class</code>. It takes the
        return value and stores it in the <CODE>ApplicationContext</code>, as a bean that can then be injected into
        other beans. </P></DIV>
<OL>
    <LI><b> ConnectionFactoryLocator connectionFactoryLocator</b> the <CODE>ConnectionFactoryLocator</CODE> contains the
        at-runtime map of which APIs are available, and can return the correct connection factory by provider id (<code>flickr</code>)
        or type (<CODE>Flickr.class</CODE>). To support Flickr, for example, we register the <CODE>FlickrConnectionFactory</CODE>,
        which in turn extends <CODE>OAuth1ConnectionFactory</CODE>. <CODE>FlickrConnectionFactory</CODE> knows how to
        establish connections to Flickr for a given client ID and client secret using OAuth 1. We could, for example,
        also register a <CODE>TwitterConnectionFactory</CODE> to support working with both Twitter and Flickr in the
        same application.
    </LI>
    <LI><b>UsersConnectionRepository usersConnectionRepository </b> The <CODE>UsersConnectionRepository</CODE> object is
        provides state for the established connections. It persists the access tokens and access token secrets about
        users that have connected to a service provider. The implementation we use here - <CODE>JdbcUsersConnectionRepository</CODE>
        - persists its data in a SQL database, which is why we declare a reference to a
        <CODE>javax.sql.DataSource</CODE> as a dependency, in addition to the <CODE>ConnectionFactoryLocator</CODE>
        defined above. We'll look at the database being used later on when we look at our batch processing logic. The
        schema used looks like this:
        <div start="1" class="source">batch-importer/src/main/resources/social_pg.sql</div>
    </LI>
    <LI><b> ConnectionRepository connectionRepository </b> Next, we configure the <CODE>ConnectionRepository</CODE>
        object which is an object that provides a data access interface for user data, specifically for one user. So, it
        might manage the the Twitter and Facebook connections for one user while the user's logged into the web
        application, but then the object ceases to exist. It is simply a short-lived, user-specific view of data coming
        from the <CODE>UsersConnectionRepository</CODE> object, which in turn manages data for <EM>all</EM> users. To
        support this short lifetime, the bean is created as a <EM>scoped</EM> bean. It will live for only as long as the
        current HTTP request is being processed, and then destroyed. The bean is annotated with <CODE>@Scope</code>, and
        given a scope of <CODE>WebApplicationContext.SCOPE_REQUEST</CODE>. There are of course many such scopes. <CODE>Singleton</CODE>
        is the default, of course, and does not need to be specified.
    </LI>
    <LI><b> Flickr flickr </b> Next we create the <CODE>Flickr</CODE> object, which is the API binding that lets us work
        with the Flickr API in a type safe way. We do this by looking up the API binding through the <CODE>ConnectionRepository</CODE>,
        which in turn delegates to the <CODE>UsersConnectionRepository</CODE>, which in turn delegates to the <CODE>ConnectionFactoryLocator</CODE>.
        This object is also <code>request</code> scoped.
    </LI>
    <LI><b> ProviderSignInController providerSignInController </b> With the machinery in place, all that's left is to
        expose endpoints in the web application that can be used to connect handle the OAuth1 callback requests from the
        service provider and to drive the conversation with the service provider to sign in. Spring Social provides a
        ready-to-use implementation of all of this called <CODE>ProviderSignInController</CODE> that you need simply
        register. It's a Spring MVC controller and will automatically handle requests to the well known URLs required
        for the OAuth connection process. The one part that this object can't provide by itself is the code that signs
        in your local application's notion of a user once the service provider user has been signed in. The two need to
        be synchronized. For this, you must provide an implementation of <CODE>SignInAdapter</CODE> as the third
        argument to the constructor. Our implementation, <code>org.springframework.social.flickr.user.SimpleSignInAdapter</code>
        simply generates a cookie when a user is successfully logged in and stores some user state in the HTTP session.
        <div class="source">web/src/main/java/org/springframework/social/flickr/user/SimpleSignInAdapter.java</div>
    </LI>
</OL>
<h3> What's this Buy Us? </h3>

<P> Simple! It buys you a web application that can connect to Flickr and then return the signed in user context back to
    the web application. </P>

<p>

<div><img src="ssf_web_1.png" width="600"/></div>
When you launch the web application, you'll be greeted with a prompt to login. The page itself (presented below) is very
trivial, and simply <CODE>POST</CODE>s to the configured <CODE>ProviderSignInController</CODE>, which in turn starts the
login flow. </p>
<div class="source" start="1">web/src/main/webapp/WEB-INF/jsp/signin.jsp</div>
<div><img src="ssf_web_2.png" width="600"/></div>
<P> This in turn causes a redirect to the service provider, where the user is prompted to authenticate himself. </P>

<div><img src="ssf_web_3.png" width="600"/></div>
<P> Once authenticated, the service provider (Flickr, in this case) redirects <EM>back</EM> to the original application
    with an access token in the request, which the source application can pluck out of the request and store for later
    use. On the server side, the effect to you, as an application developer, is that you can make use of an injected
    <CODE>Flickr</CODE> instance as you see fit. The <CODE>welcome.jsp</CODE> page presents a lot of different tools
    that make use of the Spring Social Flickr API, including a link to launch a batch process to download everything.
    Let's look at that. </P>

<h2> Batching with Spring Batch </h2>

<P> With the Spring MVC and Spring Social configuration all set up, we now have the ability to obtain a reference to a
    valid reference to a <CODE>Flickr</CODE> API implementation that we can use to drive our batch process. Spring Batch
    makes it very easy to describe complex batch processing workflows as a series of <CODE>step</CODE>s inside of a
    single <CODE>job</CODE> using the Spring Batch Java DSL available in Spring Batch 2.2. </P>

<h3>Setting up Common Infrastructure </h3>

<P> To use Spring Batch, you need to configure a few things common to all Spring Batch <CODE>job</code>s. Spring Batch
    can set up most of the machinery required to use it by simply placing the <Code>@EnableBatchProcessing</Code>
    annotation on your <CODE>@Configuration</CODE> class. From there, you need only define a few things specific to the
    desired behavior of your application. Next, you need to configure a database connection
    (<CODE>javax.sql.DataSource</CODE>) which in turn requires a few database tables that Spring Batch uses to handle
    the bookkeeping related to the state of batch jobs. Since Spring Batch needs to handle transactions, you also need
    to create a <CODE>PlatformTransactionManager</CODE> bean that can be used with the transactional resource (in this
    case, the <CODE>DataSource</CODE>). Finally, since - when we launch the jobs - we keep a thread running in the
    background to garbage collect any references to completed jobs. This requires a <CODE>TaskScheduler</CODE>. These
    beans are defined below: </p>

<DIV class="source">
    batch-importer/src/main/java/org/springframework/social/importer/config/BatchInfrastructureConfiguration.java
</DIV>
<P> All the schema in this blog are for PostgreSQL. It's not hard to modify them for other databases and, in the case of
    Spring Batch's schemas, you don't even need to do that much because there are <a
            href="https://github.com/SpringSource/spring-batch/tree/master/spring-batch-core/src/main/resources/org/springframework/batch/core">
        multiple permutations of the schema defined with the project for many different databases</a>. </P>

<h3> Defining our Import Job </h3>

<p> Here's the configuration for our <CODE>flickrImportJob</CODE> job.</p>

<div class="source">
    batch-importer/src/main/java/org/springframework/social/importer/config/BatchImporterConfiguration.java
</div>
<P> The configuration defines one <CODE>job</CODE> (<code>@Bean Job flickrImportJob</code>) which in turn defines a flow
    between three <CODE>step</CODE>s. This job is charged with loading information about all the albums from Flickr into
    a database (<CODE>step1</CODE>), then loading all information for the photos for each album into a database (<CODE>step2</CODE>),
    and then, for each photo, downloading the photo from Flickr into folders on the file system corresponding to each
    photo album (<CODE>step3</CODE>). We could just read the information from the Flickr web service and start
    downloading them directly, but then we wouldn't have a way to measure progress and resume the downloads if the batch
    job failed. Keeping them in the database is fast and cheap and makes it easy for Spring Batch to help us keep track
    of things. </P>

<P> Each <CODE>step</CODE> defines the <EM>chunk</EM> it wants to work with (e.g., how many records should be read
    before a write is attempted), which in turn manages a <CODE>reader</CODE>, a <CODE>writer</CODE>, and optionally a
    <CODE>processor</CODE>. The beans for the <CODE>reader</CODE>s (subclasses of <CODE>ItemReader</CODE>),
    <CODE>writer</CODE>s (subclasses of <CODE>ItemWriter</CODE>), and <CODE>processor</CODE>s (subclasses of <CODE>ItemProcessor</CODE>)
    are configured using Java configuration. The <CODE>reader</CODE>s read data from some data source, like a database,
    a file system, or a web service like Flickr. The <CODE>processor</CODE>s, if specified, take the output from the
    reader and optionally augment, update or transform them in some way to be suitable for the <CODE>writer</CODE>. The
    <CODE>writer</CODE>s take the output from the reader (or, optionally, from the <CODE>processor</CODE>) and write
    them to some data source, like a database, a file system, or a web service like Flickr. Let's work through the
    configuration class to see how how many of the beans work. The first thing you should note is how little is actually
    code we had to write. Most of the beans defined here are <CODE>ItemWriter</CODE> and <CODE>ItemReader</CODE>
    implementations (<CODE>JdbcCursorItemReader</CODE> for reading, <CODE>JdbcBatchItemWriter</CODE> for writing) that
    Spring Batch provides out of the box that make dealing with working with JDBC a breeze. </P>

<P> Let's look at the <CODE>step</CODE>s.</P>
<OL>
    <LI><B>step1</B>: defines a <CODE>reader</CODE> and a <CODE>writer</CODE>. The reader
        (<CODE>photoAlbumItemReader</CODE>) is a custom <CODE>ItemReader</CODE> class (<CODE>PhotoSetItemReader</CODE>)
        that depends on the scoped <CODE>Flickr</CODE> instance. The <CODE>@Bean</CODE> definition for this class has
        <CODE>@StepScoped</CODE>, which tells Spring Batch to create a new instance of this bean for <EM>every</EM>
        <CODE>step</CODE> it's executed since it keeps state and can not be shared. The class itself is very simple.
        Once it's configured and started up, it makes a call using the Flickr API binding, and retreives objects
        representing all the photo sets (photo albums, or compilations) and then caches them. As Spring Batch asks it
        one by one for the next record, the class simply takes one at a time from the queue, removes it from the queue,
        adapts it into a domain model object for this <CODE>job</CODE>, and returns it.
        Here is the code:
        <div class="source">
            batch-importer/src/main/java/org/springframework/social/importer/batch/PhotoSetItemReader.java
        </div>


        With this, the
        <CODE>writer</CODE> (<code>photoAlbumItemWriter</code>) can now write information about the photo set into the
        database. The <code>photoAlbumItemWriter</code> is a bean of type <CODE>JdbcBatchItemWriter</CODE>, which Spring
        Batch provides. The <CODE>JdbcBatchItemWriter</CODE> needs the usual things - a <CODE>dataSource</CODE> to work
        with, a <CODE>SQL</code> statement to execute, and a way of mapping the output of the <CODE>reader</CODE> (an
        object of type <CODE>PhotoSet</CODE>) to the named parameters in the SQL statement. If you've ever used Spring's
        <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/jdbc.html#jdbc-JdbcTemplate"><CODE>JdbcTemplate</CODE></a>,
        then you'll recognize the <CODE>SqlParameterSource</CODE> which Spring Batch requires to correctly build up the
        prepared statement. To satisfy this requirement, the <CODE>JdbcBatchItemWriter</CODE> requires a a <CODe>ItemSqlParameterSourceProvider</CODe>
        implementation which essentially bundles up the parameters into a map of named prepared statement parameters to
        values.
    </LI>
    <LI><b>step2</b>: This step's slightly more tricky. In this one, we actually <EM>nest</EM> our readers. We want to
        read from all the <CODE>PhotoSet</CODE>s in the database, then, for each <CODE>PhotoSet</CODE>, read all the
        <CODE>Photo</CODE>s from the Flickr web service and write them to the database. This approach is useful for
        supporting reading master-detail data sets. The <CoDE>ItemReader</CoDE> is in a class called <CODE>DelegatingPhotoSetPhotoItemReader</CODE>.
        It delegates to an instance of <CODE>JdbcCursorItemReader</CODE> to read a <CODE>PhotoSet</CODE> from the
        database (the data we wrote in <CODE>step1</CODE>), and then, for each new <CODE>PhotoSet</CODE>, queries the
        Flickr web service for all the photos that belong to that <CODE>PhotoSet</CODE>, which it then caches locally
        and - one at a time - returns them until all the <CODE>Photo</CODE>s for a given <CODE>PhotoSet</CODE> have been
        read, at which point a <EM>new</EM> <CODE>PhotoSet</CODE> is read from the database and the cyle continues.
        Here's the source code for the <CODE>DelegatingPhotoSetPhotoItemReader</CODE>.
        <div class="source">
            batch-importer/src/main/java/org/springframework/social/importer/batch/DelegatingPhotoSetPhotoItemReader.java
        </div>
        Spring Batch supports <EM>resuming</EM> reads for <CODE>ItemReader</CODE> implementations that also support the
        <CODE>ItemStream</CODE> interface. If you register a bean such as this as a <CODE>reader</CODE> then Spring
        Batch will automatically call back the appropriate interface methods and give the <CODE>ItemReader</CODE> a
        chance to persist its state (e.g., how far it's gotten). The delegate <CODE>JdbcCursorItemReader</CODE> supports
        this property, but since we're embedding it in our <CODE>DelegatingPhotoSetPhotoItemReader</CODE>, we need to
        tell Spring Batch to honor the <CODE>ItemStream</CODE> contract for us. We do this by calling the <CODE>stream(ItemStream)</CODE>
        method when building the <CODE>Step</CODE> in the <CODE>@Bean public Step step2</CODE> Java configuration
        method.

        The <CODE>writer</CODE> (<code>photoDetailItemWriter</code>) is another <CODE>JdbcBatchItemWriter</CODE>
        which simply writes information about each <CODE>Photo</CODE> to the <CODE>photos</CODE> table.

    </LI>
    <LI>
        <B>step3</B>:
        The first two <CODE>step</CODE>s execute very quickly, relatively.
        Even with tens of thousands of records, this should not take more than a few minutes on a modern machine.
        This last step is where the proverbial rubber meets the road: it finds all the unprocessed photos, downloads
        them, and then acknowledges the download.

        It requires a <CODE>reader</CODE>, a <CODE>processor</CODE> and a <CODE>writer</CODE>.

        The <CODE>reader</CODE> is an instance of <CODE>JdbcCursorItemReader</CODE>
        which reads through all the records in the <CODE>photos</CODE> table, and passes them through a
        <CODE>RowMapper</CODE> (which you might <EM>also</EM> recognize from core Spring's <CODE>JdbcTemplate</CODE>)
        which takes a JDBC <CODE>ResultSet</CODE> and adapts it to the domain model of our batch application, in this
        case, a
        <CODE>Photo</CODE>.
        The SQL is a simple <Code>SELECT</Code> statement, filtering all the records that have not been
        downloaded.

        The <CODE>Photo</CODE> is then passed to the <CODE>ItemProcessor</CODE> (an class called <CODE>PhotoDownloadingItemProcessor</CODE>)
        which uses the <CODE>Flickr</CODE> we worked so hard to set up to download the actual bytes for the photograph.
        The <CODE>ItemProcessor</CODE> calculates the right path to which the photograph should be written, using the
        Flickr user ID,
        photo set ID,
        and the photo ID. It ensures that this directory exists on the file system. Then it reads a
        <Code>BufferedImage</Code> into
        memory and writes the bytes to the file described by the previously calculated path.
        <div class="source">
            batch-importer/src/main/java/org/springframework/social/importer/batch/PhotoDownloadingItemProcessor.java
        </div>

        There is a small optimization here so that, if the file already exists and has data (greater than 0 bytes in
        size),
        it is not re-downloaded.

        Assuming everything goes well, the <CODE>Photo</CODE> object for the downloaded image is returned from the
        <Code>ItemProcessor</Code>
        where it's sent to the <CODE>ItemWriter</CODE> (a bean named <CODE>photoDownloadedAcknowledgingItemWriter</CODE>).
        The <CODE>ItemWriter</CODE>
        is simply another instance of <CODE>JdbcBatchItemWriter</CODE> that simply <EM>acknowledges</EM> the
        download by updating a flag in the <CODE>photos</CODE> table for the appropriate record.

    </LI>
</OL>
<DIV class="sidebar"><h1> Upserts </h1> The SQL syntax used in some of these JDBC writers might seem a little exotic to
    the uninitiated. It is the PostgreSQL equivalent of an <EM><a
            href="http://en.wikipedia.org/wiki/Merge_(SQL)">upsert</a></EM>. Many databases support some
    database-specific equivalent of this
    functionality: it <Code>inserts</Code> data with a given key if no existing row is found to have the same
    key, or, alternatively, <EM>updates</EM> the existing data with the same key.
    This helps ensure that, if the job is stopped and re-run, there are no duplicate records.
</div>

<h3>
    Working with the Batch Process from the Web Application
</h3>

<P> This whole batch process is nicely wrapped up in a separate class and package. I made it possible to launch this
    batch job from
    within the web application by exposing a URL (<CODE>/batch/start</CODE>) which automatically starts the download for
    the given user.


</P>

<DIV class="source">
    web/src/main/java/org/springframework/social/flickr/BatchDownloadController.java
</DIV>
<p> The controller simply injects a reference to the current, scoped <CODE>Flickr</CODE> object and an instance to
    a configured <CODE>FlickrImporter</CODE> class.

    The <CODE>FlickrImporter</CODE> class simply provides a facade around
    the machinery to run and manage Spring Batch <CODE>jobs</CODE>.

    There are two ways to run this application - in the web environment, where Spring Social will automatically renew
    your access token and access token secret,
    or on the command line, in which ase you need to provide the access token and access token secret. If you run this
    application on the command line, the code assumes that you specify the required client ID, client secret, access
    token, and access token secret as
    <EM>parameters</EM> to the when you launch it. The <CODE>FlickrImporter#startImport(String userId, String at, String
        atSecret, String consumerKey, String consumerSecret, File file) </CODE>
    variant handles this use case. If you run the batch job from within the web application, Spring Social automatically
    furnish us
    with a valid <CODE>Flickr</CODE> object and we don't need to manage one as part of the Spring Batch job, we can
    simply use the one that
    is bound to our web session.
    The <CODE>FlickrImporter#startImport(String userId, File out)</CODE> variant handles this use case.

</p>

<P>
    Spring Batch jobs are run using the <CODE>JobLauncher</CODE> object, an instance of which Spring Batch will
    automatically create when you use the <CODE>@EnableBatchProcessing</CODE>
    annotation. You need only inject that instance into the appropriate code.

    The <CODE>JobLauncher#run</CODE> method expects a pointer to the defined <CODE>Job</CODE> object, and
    it expects parameters - arguments to the batch job that differentiate the batch job from the previous ones.
    If you ran a daily report every day at 2AM, then perhaps the parameter would be the timestamp.
    In our case, we need to specify the <CODE>userId</CODE>, and the output directory, at a minimum. So both variants of
    the <CODE>startImport</CODE>
    method spend time building up a <CODE>JobParameters</CODE> instance, which is then ultimately passed to the
    <CODE>JobLaucher</CODE> instance.

</p>
 <P> Here's the code for the <CODE>FlickrImporter</CODE> object.</P>
<div class="source">
    batch-importer/src/main/java/org/springframework/social/importer/FlickrImporter.java
</div>
<P> Because we expect to  use this object from a user interface (a web console), we expose support for querying the progress of the various albums.
    To support this, the <CODE>Collection&lt;PhotoSet&gt; photoSetsImportedForUser(String userId)</CODE> method
    returns information about all the <CODE>PhotoSets</CODE> based on a SQL projection that calculates how many photos have been downloaded, imported, etc.
    This information is then made available to the user looking at the console, like this:
</P>
<div><img src="ssf_web_4.png" width="600"/></div>
<H2>
Conclusion
</H2>
<P> Spring Social provides a very natural way to work with social service providers like Flickr and Facebook and Twitter. However, these providers are
 as successful as they are because they've managed to deal with <EM>lots</EM> of data. In order to integrate with them, you need to think about scaling your application
    as well. Spring Batch makes chewing through large workloads in a reliable way a breeze, as you've hopefully seen, and these two projects work very well together!
</P>
<a name="end"/></body>
</html>